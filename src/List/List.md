## リスト
```haskell
-- リスト
let list = [1,2,3]
{-
list
[1,2,3]

list ++ list
[1,2,3,1,2,3]
-}

-- Haskell では、文字列は文字のリストとして扱うらしい
"word" == ['w', 'o', 'r', 'd']

-- ++ で連結する時はリストの最後まで操作するためmリストの先頭に追加する場合は : を使用する
'a' + "bcd"

-- 要素へのアクセス
 "aiueo" !! 2
-- 'u'
"aiueo" !! 6 -- エラーになる
-- *** Exception: Prelude.!!: index too large

-- 比較
-- リスト同士の比較をすると先頭から辞書順で比較されていく: >, >=, <, <=, == で比較可能
[1,2,3] > [1,2,4]
-- True
[1,2,3] > [1,2,3]
-- False
[1,2,3,4] > [1,2,3]
-- False

-- リスト操作
 head "aiueo"
-- 'a'

tail "aiueo"
-- "iueo"

-- ⋮
-- last, init, length など他にも色々（空のリストに関数を実行するとエラーになる: コンパイル時にわからないエラー）

-- 空かどうか調べられる関数
null [1,2]
-- False
null []
-- True

-- 含まれるかどうか
elem 1 [1,3,4]
-- True
elem 1 [3,4]
-- False
```

## レンジ
```haskell
-- 列挙できる要素の組み合わせでリスト作成できる
let twenty = [1..20]
-- [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
let alpha = ['A'..'Z']
-- "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
["AIUEO".."OOOOO"]
--  No instance for (Enum String)

-- ステップ
[2,4..20]
-- [2,4,6,8,10,12,14,16,18,20]
-- 累乗とかはできないらしい

-- NOTE
[20..1]
-- [] <- 空になる
[20,19..1]
-- [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]

-- 無限リスト
[13,26..]
-- [13,26......]

take 10 [13,26..]
-- [13,26,39,52,65,78,91,104,117,130]
-- 遅延評価しているため、無限リストをすぐに評価しない

-- 一生同じことを繰り返す
cycle "AIUEO   "
-- AIUEO   AIUEO   AIUEO   AIUEO   AIUEO  .....

-- 浮動小数点は精度が良くない
[0.1, 0.3..1]
-- [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```

## 内包表記
```haskell
{-
構文
[ 1. 抽出した値に対して行う処理 | 2. 配列から抽出する処理、3. フィルタリングを行う処理 ]
-}
[x | x <- [1..100], x `mod` 3 == 0]
-- [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99]

-- 複数もいける
[x*y | x <- [1..10], y <- [1..10], x*y > 50]
-- [54,60,56,63,70,56,64,72,80,54,63,72,81,90,60,70,80,90,100]
[x*y | x <- [1..10], y <- [1..10], x > 50]
-- []

[prefix ++ name | prefix <- ["Hello! "], name <- ["Haskell", "Scala", "TypeScript", "HTML", "Java"], name /= "HTML", name /= "Java"]
-- ["Hello! Haskell","Hello! Scala","Hello! TypeScript"]

sum [1 | _ <- ['A'..'Z']]
-- 26
```
